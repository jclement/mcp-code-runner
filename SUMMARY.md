# MCP Code Sandbox Server - Implementation Summary

## What We Built

A complete, production-ready MCP-compatible code execution service with:

### Core Features
✅ **MCP JSON-RPC 2.0 API** - Full protocol implementation
✅ **Multi-language Support** - Python & TypeScript runners
✅ **Sandboxed Execution** - Isolated Docker containers
✅ **Persistent Storage** - Per-conversation `/data` directory
✅ **Signed File URLs** - HMAC-SHA256 secured downloads
✅ **Web Interface** - Interactive browser UI for testing
✅ **Docker Deployment** - Multiple deployment options

### Security Features
✅ Network-isolated containers
✅ Non-root execution (UID 1000)
✅ Resource limits (0.5 CPU, 256MB RAM)
✅ 30-second execution timeout
✅ Bearer token authentication
✅ Path traversal protection
✅ Constant-time signature comparison

## Project Structure

```
code-runner/
├── cmd/server/                # Go server application
│   └── main.go
├── internal/                  # Internal packages
│   ├── auth/                 # Bearer token middleware
│   ├── config/               # Environment configuration
│   ├── filesign/             # HMAC-SHA256 URL signing
│   ├── handler/              # HTTP + JSON-RPC handlers
│   ├── runner/               # Docker container execution
│   └── sandbox/              # Filesystem management
├── static/                   # Web interface
│   └── index.html           # Interactive testing UI
├── Dockerfile               # Server container (multi-stage build)
├── Dockerfile-python        # Python 3.11 runner (inline script)
├── Dockerfile-typescript    # TypeScript/Node 22 runner (inline script)
├── docker-compose.yml       # Local development setup
├── docker-compose-cloudflare.yml  # Production w/ Cloudflare Tunnel
├── build.sh                 # Build script (images + binary)
├── quickstart.sh            # One-command setup
├── .env.example             # Configuration template
├── .gitignore              # Git exclusions
├── .dockerignore           # Docker build exclusions
├── README.md               # Full documentation
├── DOCKER.md               # Docker deployment guide
└── PLAN.md                 # Original specification
```

## Key Implementation Details

### 1. Docker Runner Architecture

**Runner Discovery**: Uses Docker labels
```dockerfile
LABEL sandbox.runner=true
LABEL sandbox.language=python
```

**Inline Scripts**: Runner logic embedded in Dockerfiles (no external files)
```dockerfile
RUN cat > /usr/local/bin/runner.sh <<'EOF'
#!/bin/sh
# Script contents inline
EOF
```

### 2. Container Execution Flow

1. Client sends JSON-RPC request to `/mcp`
2. Server validates auth token
3. Parses `sandbox.run_code` parameters
4. Creates sandbox directory: `{SANDBOX_ROOT}/{conversationId}/files`
5. Spins up runner container with volume mount
6. Pipes code to container STDIN
7. Captures STDOUT/STDERR
8. Lists generated files
9. Returns output + signed download URLs

### 3. API Endpoints

| Endpoint | Method | Auth | Purpose |
|----------|--------|------|---------|
| `/` | GET | No | Web interface |
| `/mcp` | POST | Bearer | JSON-RPC tool calls |
| `/mcp/events` | GET | Bearer | SSE notifications |
| `/files/{conv}/{file}?sig=...` | GET | Signed URL | File downloads |

### 4. JSON-RPC Tools

**`sandbox.run_code`**
```json
{
  "conversationId": "string",
  "language": "python|typescript",
  "code": "string"
}
```

**`sandbox.list_runners`**
```json
{} // No arguments
```

### 5. Deployment Options

**Local Development** (docker-compose.yml)
- Exposes port 8080
- Direct access
- Good for testing

**Cloudflare Tunnel** (docker-compose-cloudflare.yml)
- No exposed ports
- Routes through Cloudflare network
- Production-ready
- Requires `TUNNEL_TOKEN`

### 6. Web Interface Features

- Interactive code editor
- Language selector (Python/TypeScript)
- Pre-built examples:
  - Python: Hello World, Data Analysis (pandas)
  - TypeScript: Hello World, Math/Fibonacci
- Real-time execution output
- File download links
- Success/failure indicators

## Configuration

### Required Environment Variables

```bash
MCP_API_TOKEN=<bearer-token>       # API authentication
FILE_SECRET=<signing-secret>       # File URL signing
SANDBOX_ROOT=/var/sandboxes        # Storage location
PUBLIC_BASE_URL=http://localhost:8080  # Server URL
```

### Optional Variables

```bash
MCP_HTTP_ADDR=:8080               # Bind address
TUNNEL_TOKEN=<cloudflare-token>   # For Cloudflare deployment
DOCKER_HOST=unix:///var/run/docker.sock  # Docker socket
```

## Quick Start Commands

```bash
# One-line setup
./quickstart.sh && docker-compose up -d

# Manual setup
./build.sh
cp .env.example .env
# Edit .env with your tokens
docker-compose up -d

# Access web interface
open http://localhost:8080
```

## Files Generated by Build

**Docker Images:**
- `runner-python` - Python 3.11 + numpy + pandas
- `runner-typescript` - Node 22 + TypeScript + ts-node
- `mcp-sandbox-server` - Go server (multi-stage build)

**Binary:**
- `bin/mcp-sandbox-server` - Standalone executable

## Testing

### Via Web Interface
1. Open `http://localhost:8080`
2. Enter API token
3. Select language and example
4. Click "Run Code"
5. View output and download files

### Via curl

```bash
curl -X POST http://localhost:8080/mcp \
  -H "Authorization: Bearer $MCP_API_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "jsonrpc": "2.0",
    "id": "1",
    "method": "tools/call",
    "params": {
      "name": "sandbox.run_code",
      "arguments": {
        "conversationId": "test",
        "language": "python",
        "code": "print(\"Hello!\")"
      }
    }
  }'
```

## Docker Socket Security

**Current Approach**: Mount `/var/run/docker.sock`
- Server can create/manage containers
- Required for dynamic runner execution
- Has elevated privileges

**Production Recommendations**:
- Run on dedicated/isolated host
- Consider Docker-in-Docker (DinD) for better isolation
- Implement AppArmor/SELinux policies
- Monitor container creation/deletion

## Extension Points

### Adding New Languages

1. Create `Dockerfile-<language>` with proper labels
2. Inline runner script using heredoc
3. Build image: `docker build -f Dockerfile-<language> -t runner-<language> .`
4. Restart server (auto-discovers via labels)

### Example: Adding Ruby

```dockerfile
FROM ruby:3.2-alpine
LABEL sandbox.runner=true
LABEL sandbox.language=ruby

RUN adduser -D -u 1000 sandbox

RUN cat > /usr/local/bin/runner.sh <<'EOF'
#!/bin/sh
set -e
TEMP_FILE=$(mktemp /tmp/main-XXXXXX.rb)
cat > "$TEMP_FILE"
cd /data
exec ruby "$TEMP_FILE"
EOF

RUN chmod +x /usr/local/bin/runner.sh && \
    chown sandbox:sandbox /usr/local/bin/runner.sh

USER sandbox
WORKDIR /data
ENTRYPOINT ["/usr/local/bin/runner.sh"]
```

## Performance Characteristics

**Container Startup**: ~500ms-2s (depending on image size)
**Code Execution**: Depends on user code (max 30s)
**File Signing**: <1ms (HMAC-SHA256)
**Concurrent Executions**: Limited by Docker daemon and host resources

**Resource Limits per Container**:
- CPU: 0.5 cores
- Memory: 256MB
- Timeout: 30 seconds
- Network: Disabled

## What's NOT Included (Future Extensions)

- ❌ Time-limited signed URLs (no expiration)
- ❌ Streaming stdout/stderr during execution
- ❌ Per-conversation resource quotas
- ❌ Container pooling/reuse
- ❌ Sandbox cleanup policies
- ❌ Rate limiting (implement at reverse proxy level)
- ❌ Metrics/observability endpoints
- ❌ JavaScript runner (Node without TypeScript)
- ❌ Admin API for managing sandboxes

## Production Checklist

- [ ] Generate strong random tokens (32+ chars)
- [ ] Configure `PUBLIC_BASE_URL` to match domain
- [ ] Set up Cloudflare Tunnel
- [ ] Enable log aggregation
- [ ] Configure volume backups
- [ ] Monitor resource usage
- [ ] Set up health checks
- [ ] Implement rate limiting (nginx/Cloudflare)
- [ ] Review and harden runner images
- [ ] Set up alerts for failures
- [ ] Document incident response procedures

## License

MIT

## Credits

Built following the MCP specification for code execution sandboxes.
Designed for integration with AI assistants (Claude, ChatGPT) via MCP protocol.
